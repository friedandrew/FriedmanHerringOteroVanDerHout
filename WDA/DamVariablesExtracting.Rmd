---
title: "DamVariablesExtracting"
author: "Jackie Van Der Hout"
date: "4/21/2022"
output: html_document
editor_options: 
  chunk_output_type: console
---

The goal of this Rmd file is to extract from each AIM sample site:
* flowline distances from sample sites to upstream dams
* number of dams per square mile per catchment 
* number of dams upstream of each sample site

The above listed variables will be used for later analysis 


```{r}
library(sf)
library(tidyverse)
library(nhdplusTools)
library(dplyr)
library(readr)
library(tmap)

```

Loading Scraped Data
```{r}
WAAIM_tidy_utm <- st_read("../New Data/WAAIM_tidy.shp") %>% 
  st_transform(crs = 26910)

counties_sf_utm<- st_read('../New Data/cb_2018_us_county_20m.shp') %>% 
  filter(STATEFP == 53) %>%  #Filter for just WA Counties
  st_transform(crs = 26910)

dam_complete_raw_utm <- st_read("../New Data/dam_complete_raw.shp") %>% 
  st_transform(crs = 26910)

flowlines_utm <- st_read("../New Data/flowlinesall.shp") %>% 
  st_transform(crs = 26910)

catchments_utm <- st_read("../New Data/catchmentsall.shp") %>% 
  st_transform(crs = 26910)
```


Number of dams upstream of each sample site 
```{r}
#selecting the counties that intersect with the catchments 
county_intersect <- counties_sf_utm[lengths(st_intersects(counties_sf_utm, WAAIM_tidy_utm)) > 0,]
dam_intersect <- dam_complete_raw_utm[lengths(st_intersects(dam_complete_raw_utm, county_intersect)) > 0,]
```


Flowline distance extracting 
*A - Snapping points to a line
```{r}
# buffer the points by the tolerance
dam_points_buf <- st_buffer(dam_intersect, 15)
  
# intersect the line with the buffer
line_intersect <- st_intersection(flowlines_utm, dam_points_buf)

# convert mutlinestrings (more than one road segment) into linestrings
line_intersect <- do.call(rbind,lapply(1:nrow(line_intersect),function(x){st_cast(line_intersect[x,],"LINESTRING")}))

# for each line intersection, calculate the nearest point on that line to our gps point
nearest_pt <- do.call(rbind,lapply(seq_along(points$id), function(i)) 
  
points[points$id==i,] %>%  st_nearest_points(line_intersect[line_intersect$id==i,]) %>% st_sf %>%
  st_cast('POINT') %>% mutate(id = i)
  

custom_snap <- function(flowlines_utm, dam_points_buf, tolerance) {
  # intersect the line with the buffer
  line_intersect <- st_intersection(line, points_buf)
  # convert mutlinestrings (more than one road segment) into linestrings
  line_intersect <- do.call(rbind,lapply(1:nrow(line_intersect),function(x){st_cast(line_intersect[x,],"LINESTRING")}))

  # for each line intersection, calculate the nearest point on that line to our gps point
##this is not working because you can't subset a function 
## https://www.statology.org/r-object-of-type-closure-is-not-subsettable/ 
  nearest_pt <- do.call(rbind,lapply(seq_along(points$id), function(i){
    points[points$id==i,] %>%  st_nearest_points(line_intersect[line_intersect$id==i,]) %>% st_sf %>%
      st_cast('POINT') %>% mutate(id = i)
    }))

  nearest_pt<- nearest_pt[seq(2, nrow(nearest_pt), by = 2),] %>%
    mutate(option = 1:nrow(.))

  # find an unambiguous reference point with only one snap option
  unambiguous_pt <- nearest_pt %>%
    group_by(id) %>%
    mutate(count = n()) %>%
    ungroup() %>%
    filter(count == 1) %>%
    slice(1)

  # calculate network distance along our line to each snapped point
  dists <- rgeos::gProject(as(line,'Spatial'), as(nearest_pt,'Spatial'))
  # join back to nearest points data
  dists <- nearest_pt %>% cbind(dists)

  # we want to recursively do the following:
  # 1. calculate the network distance from our unambiguous reference point to the next id point in the data
  # 2. keep the snapped point for that id that was closest *along the network*  to the previous id
  # 3. set the newly snapped point as our reference point
  # 4. repeat

  # get distances from our reference point to the next point id
  for(i in unambiguous_pt$id:(max(dists$id)-1)){
    next_dist <- which.min(abs(dists[dists$id== i +1,]$dists - dists[dists$id== unambiguous_pt$id,]$dists ))
    next_option <- dists[dists$id== i +1,][next_dist,]$option
    nearest_pt <- nearest_pt %>% filter(id != i+1 | option == next_option)
    unambiguous_pt <- nearest_pt %>% filter(id ==i+1 & option == next_option)
    dists <- nearest_pt %>% cbind(dists = rgeos::gProject(as(line,'Spatial'), as(nearest_pt,'Spatial')))
  }

  # and in the reverse direction
  for(i in unambiguous_pt$id:(min(dists$id)+1)){
    next_dist <- which.min(abs(dists[dists$id== i -1,]$dists - dists[dists$id== unambiguous_pt$id,]$dists ))
    next_option <- dists[dists$id== i -1,][next_dist,]$option
    nearest_pt <- nearest_pt %>% filter(id != i-1 | option == next_option)
    unambiguous_pt <- nearest_pt %>% filter(id ==i-1 & option == next_option)
    dists <- nearest_pt %>% cbind(dists = rgeos::gProject(as(line,'Spatial'), as(nearest_pt,'Spatial')))
  }

  # transform back into lat/lng
  snapped_points <- nearest_pt %>%
    st_transform(4326)

  return(snapped_points)
}

gps_snap <- custom_snap(line, gps, 15) %>%
  cbind(st_coordinates(.))
```


Number of dams per square mile per catchment 
```{r}

```

